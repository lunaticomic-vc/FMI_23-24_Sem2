Пространства от имена (Namespace). Енумерации, структури и обединения. Видове енумерации и разлики Работа с инстанции: Инициализация, достъп до елементите, влагане, работа с функции, работа с масиви. Размер на обекти/инстанции. Подравняване и отместване. Endianness и проверка за big/little endian. Пример с задачата за N триъгълника.

# Namespace

-	Namespace/Пространство от имена са именувани блокове, които предоставят метод за предотвратяване на конфликти с имена. Подобно на „папки“ с информация, те съдържат групи от символи, чиито именуван scope не позволява двусмислица със символи с идентични имена в други диапазони.

 	Обекти, декларирани извън пространство от имена принадлежат на глобалното такова.

 	Namespace-ове могат да бъдат влагани. Ако в даден Namespace бъде използван друг, който съдържа обект с повтарящо се име, този обект се „скрива“ и компилатора приема обекта на Namespace-a родител.

# Enum
-	Eнумерацията е отделен тип, чиято стойност е ограничена до диапазон от стойности, който може да включва няколко изрично посочени константи (енумератори).

 	Стойностите на константите са стойности от интегрален тип, известен като основен тип на eнумерацията

	Eнумерацията има същия размер, представяне на стойност и изисквания за подравняване като неговия основен тип.

	Освен това всяка стойност на енумерацията има същото представяне като съответната стойност на основния тип.

	Има два типа енумерации

- plain enums - енумераторите са в същия scope като enuma и техните стойности се преобразуват имплицитно към integers и други типове (включително да други enum-и )

- enum classes - енумераторите са локални за enuma и техните стойности не се преобразуват имплицитно към други типове (another enum or int). Възможно е два различни енъма да имат енумератори с еднакви имена.

  Типът на енумерацията е най-малкия тип, който побира всички обекти в нея. Той автоматично се запазва като int. Може да бъде модифициран по два начина - в него да съществува променлива със стойност над максималната за инт или да се упомене в декларацията:
```
enum Test:char {
	a=0;
	b=12; //Ако някоя променлива надхвърли максималната стойност на типа, енъма се чупи
}
```

# Struct
-	Структурите в C++ се използват за групиране на елементи. Елементите, наричани още членове, могат да бъдат от различен тип(int, int[], bool и т.н.) и с различна големина. Могат да се подават по референция, константна референция и по копие.

	Паметта е байт-адресируема, т.е. може да достъпва всеки байт индивидуално;

	Колко памет може да прочете процесорът за един memory read cycle-a зависи от архектурата му (x32 - 4 bytes, x64 - 8 bytes);

	В паметта променливите са разположени в същия ред, в който са декларирани в структурата;

	Подравняването на една структура става по големината на най-голямата член-данна (даже и в случая на вложена структура) на структурата (с цел минимизация на подравняването и броя read cycle-и за прочитане на най-голямата член-данна да бъде оптимален);

	За да бъде минимална паметта, която ползва една структура, трябва да подредим нейните член-данни в нарастващ или намаляващ ред по големина на променливата

	sizeof на празна структура (без член-данни) е равна на 1

# Работа с инстанции

```
struct A
{
	int a;
	char b;
}

А obj = { 17, 'b'}; //Инициализация
А* ptr = new A[10]; //Динамична памет
obj.a--; //достъп
A* p = &obj; //достъп до указател
p->a++;
(*p).a++;
```
Подаването на инстанции във функции става по 6 начина:

```
f1 (A obj);
f2 (const A obj);
f3 (A &ref);
f4 (const A &obj);
f5 (A* ptr);
f6 (const A* ptr);
```

NB! Следи се за const correctness !!!!!!!!!!!! 

Правило за влагане на инстанции: Ако една функция изисква константа, в нея не може да се подаде функция, изискваща референция.

Връщане на инстанции от функция:
- по копие
- по референция - Трябва да сме сигурни, че обекта съществува след края на функцията.
```
A obj;
A& f()
{
	obj.a++;
	return obj;
}
```
Ако обектът е локален, можем да "удължим живота му" до функцията, в която е извикан.
```
struct A
{
	int a ;
	char b ;
};

const A& f() 
{
	A obj;
	obj.a = 1;
	obj.b = 66;
	return obj;
}

int g()
{
	A obj1 = f();
	return obj1.a;
}

int main()
{
	cout << g() << endl; //1
}

```

- по показател
```
A* f(){
  	A* obj;
	return &obj;
  }
```
- Формално валидно е да се подаде като динамична памет, но не е коректно, защото потребителя на функцията трябва да се "сети" да я изтрие.
  ```
  A* f(){
  	A* ptr = new A {...};
  	return ptr;
  }

	int main()
{
	A* ptr = f();
	cout << *ptr;
	delete ptr;
}
  ```
- Като константен показател:
```
struct A
{
	int a ;
	char b ;
};

const A* f() 
{
	A obj;
	obj.a = 1;
	obj.b = 66;
	return &obj;
}

int g()
{
	const A* obj1 = f();
	return obj1->a;
}

int main()
{
	cout << g() << endl; //1
}
```

# Union
-	Обединенията е специален вид структура, чиито член-данни(дори и от различен тип) споделят една и съща памет. Едно обединение заема памет, колкото е големината на най-голямата му променлива в обединението. Във всеки един момент обаче може да се ползва само една променлива от състава на обединението.

  # Endianness
-	Съществуват следните два начина за запазване на байтовете на типове данни, които имат размер по-голям от 1 байт:

 	Little-endian - Най-старшият байт е на последна позиция, най-младшият е на първа

	Big-endian - Най-старшият байт е на първа позиция, най-младшият е на последна


```
