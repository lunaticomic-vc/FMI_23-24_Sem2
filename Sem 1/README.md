Пространства от имена (Namespace). Енумерации, структури и обединения. Видове енумерации и разлики Работа с инстанции: Инициализация, достъп до елементите, влагане, работа с функции, работа с масиви. Размер на обекти/инстанции. Подравняване и отместване. Endianness и проверка за big/little endian. Пример с задачата за N триъгълника.

-	Namespace/Пространство от имена са именувани блокове, които предоставят метод за предотвратяване на конфликти с имена. Подобно на „папки“ с информация, те съдържат групи от символи, чиито именуван scope не позволява двусмислица със символи с идентични имена в други диапазони. Обекти, декларирани извън пространство от имена принадлежат на глобалното такова. Namespace-ове могат да бъдат влагани. Ако в даден Namespace бъде използван друг, който съдържа обект с повтарящо се име, този обект се „скрива“ и компилатора приема обекта на Namespace-a родител.
  
-	Eнумерацията е отделен тип, чиято стойност е ограничена до диапазон от стойности, който може да включва няколко изрично посочени константи (енумератори). Стойностите на константите са стойности от интегрален тип, известен като основен тип на eнумерацията Eнумерацията има същия размер, представяне на стойност и изисквания за подравняване като неговия основен тип. Освен това всяка стойност на енумерацията има същото представяне като съответната стойност на основния тип. Има два типа енумерации
o	 plain enums - енумераторите са в същия scope като enuma и техните стойности се преобразуват имплицитно към integers и други типове (включително да други enum-и )
o	 Enum classes - енумераторите са локални за enuma и техните стойности не се преобразуват имплицитно към други типове (another enum or int). Възможно е два различни енъма да имат енумератори с еднакви имена.

-	Структурите в C++ се използват за групиране на елементи. Елементите, наричани още членове, могат да бъдат от различен тип(int, int[], bool и т.н.) и с различна големина. Могат да се подават по референция, константна референция и по копие.
o	 Паметта е байт-адресируема, т.е. може да достъпва всеки байт индивидуално;
o	Колко памет може да прочете процесорът за един memory read cycle-a зависи от архектурата му (x32 - 4 bytes, x64 - 8 bytes);
o	В паметта променливите са разположени в същия ред, в който са декларирани в структурата;
o	Подравняването на една структура става по големината на най-голямата член-данна (даже и в случая на вложена структура) на структурата (с цел минимизация на подравняването и броя read cycle-и за прочитане на най-голямата член-данна да бъде оптимален);
o	За да бъде минимална паметта, която ползва една структура, трябва да подредим нейните член-данни в нарастващ или намаляващ ред по големина на променливата
o	sizeof на празна структура (без член-данни) е равна на 1

-	Обединенията е специален вид структура, чиито член-данни(дори и от различен тип) споделят една и съща памет. Едно обединение заема памет, колкото е големината на най-голямата му променлива в обединението. Във всеки един момент обаче може да се ползва само една променлива от състава на обединението.
-	
-	Съществуват следните два начина за запазване на байтовете на типове данни, които имат размер по-голям от 1 байт:
Little-endian - Най-старшият байт е на последна позиция, най-младшият е на първа
Big-endian - Най-старшият байт е на първа позиция, най-младшият е на последна
Проверката може да се извърши чрез побитова операция върху указател.

    unsigned int num = 1;
    // Check the least significant byte
    if (*((char*)&num) == 1) {
        std::cout << "Little-endian" << std::endl;
    } else {
        std::cout << "Big-endian" << std::endl;
    }

