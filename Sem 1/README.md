Пространства от имена (Namespace). Енумерации, структури и обединения. Видове енумерации и разлики Работа с инстанции: Инициализация, достъп до елементите, влагане, работа с функции, работа с масиви. Размер на обекти/инстанции. Подравняване и отместване. Endianness и проверка за big/little endian. Пример с задачата за N триъгълника.

# Namespace

Namespace/Пространство от имена са именувани блокове, които предоставят метод за предотвратяване на конфликти с имена. Подобно на „папки“ с информация, те съдържат групи от символи, чиито именуван scope не позволява двусмислица със символи с идентични имена в други диапазони.

 	Обекти, декларирани извън пространство от имена принадлежат на глобалното такова.

 	Namespace-ове могат да бъдат влагани. Ако в даден Namespace бъде използван друг, който съдържа обект с повтарящо се име, този обект се „скрива“ и компилатора приема обекта на Namespace-a родител.

# Enum
Eнумерацията е отделен тип, чиято стойност е ограничена до диапазон от стойности, който може да включва няколко изрично посочени константи (енумератори).

 	Стойностите на константите са стойности от интегрален тип, известен като основен тип на eнумерацията

	Eнумерацията има същия размер, представяне на стойност и изисквания за подравняване като неговия основен тип.

	Освен това всяка стойност на енумерацията има същото представяне като съответната стойност на основния тип.

	Има два типа енумерации

- plain enums - енумераторите са в същия scope като enuma и техните стойности се преобразуват имплицитно към integers и други типове (включително да други enum-и )

- enum classes - енумераторите са локални за enuma и техните стойности не се преобразуват имплицитно към други типове (another enum or int). Възможно е два различни енъма да имат енумератори с еднакви имена.

  Типът на енумерацията е най-малкия тип, който побира всички обекти в нея. Той автоматично се запазва като int. Може да бъде модифициран по два начина - в него да съществува променлива със стойност над максималната за инт или да се упомене в декларацията:
```
enum Test:char {
	a=0;
	b=12; //Ако някоя променлива надхвърли максималната стойност на типа, енъма се чупи
}
```

# Struct
Структурите в C++ се използват за групиране на елементи. Елементите, наричани още членове, могат да бъдат от различен тип(int, int[], bool и т.н.) и с различна големина. Могат да се подават по референция, константна референция и по копие.

	Паметта е байт-адресируема, т.е. може да достъпва всеки байт индивидуално;

	Колко памет може да прочете процесорът за един memory read cycle-a зависи от архектурата му (x32 - 4 bytes, x64 - 8 bytes);

	В паметта променливите са разположени в същия ред, в който са декларирани в структурата;

	Подравняването на една структура става по големината на най-голямата член-данна (даже и в случая на вложена структура) на структурата (с цел минимизация на подравняването и броя read cycle-и за прочитане на най-голямата член-данна да бъде оптимален);

	За да бъде минимална паметта, която ползва една структура, трябва да подредим нейните член-данни в нарастващ или намаляващ ред по големина на променливата

	sizeof на празна структура (без член-данни) е равна на 1

# Работа с инстанции

```
struct A
{
	int a;
	char b;
}

А obj = { 17, 'b'}; //Инициализация
А* ptr = new A[10]; //Динамична памет
obj.a--; //достъп
A* p = &obj; //достъп до указател
p->a++;
(*p).a++;
```
Подаването на инстанции във функции става по 6 начина:

```
f1 (A obj); //по копие
f2 (const A obj); //по константно копие
f3 (A &ref); //по референция
f4 (const A &obj); //по константна референция
f5 (A* ptr); //по указател
f6 (const A* ptr); //по указател към константа
```

NB! Следи се за const correctness !!!!!!!!!!!! 

Правило за влагане на инстанции: Ако една функция изисква константа, в нея не може да се подаде функция, изискваща референция.

Връщане на инстанции от функция:
- по копие
- по референция - Трябва да сме сигурни, че обекта съществува след края на функцията.
```
A obj;
A& f()
{
	obj.a++;
	return obj;
}
```
Ако обектът е локален, можем да "удължим живота му" до функцията, в която е извикан.
```
struct A
{
	int a ;
	char b ;
};

const A& f() 
{
	A obj;
	obj.a = 1;
	obj.b = 66;
	return obj;
}

int g()
{
	A obj1 = f();
	return obj1.a;
}

int main()
{
	cout << g() << endl; //1
}

```

- по показател
```
A* f(){
  	A* obj;
	return &obj;
  }
```
- Формално валидно е да се подаде като динамична памет, но не е коректно, защото потребителя на функцията трябва да се "сети" да я изтрие.
```
  A* f(){
  	A* ptr = new A {...};
  	return ptr;
  }

	int main()
{
	A* ptr = f();
	cout << *ptr;
	delete ptr;
}
```
- Като константен показател:
```
struct A
{
	int a ;
	char b ;
};

const A* f() 
{
	A obj;
	obj.a = 1;
	obj.b = 66;
	return &obj;
}

int g()
{
	const A* obj1 = f();
	return obj1->a;
}

int main()
{
	cout << g() << endl; //1
}
```
Размер на инстанция - размерът е кратен на най-голямата по размер променлива. Нейният адрес трябва да започва на кратна на размера й позиция. Alignment се нарича разликата между два адреса, на които можем да разположим променлива. Вложените структури наследяват alignment.
```
struct A
{
	int a;
	char b;
}; //alignof(A) = 4

struct B
{
	A obj;
	char ch;
}; //alignof(B)=12, защото променливите в А се нуждаят от адреси кратни на 4, а ch от адрес кратен на 1 => Цялото се приравнява към адреси кратни на 4 и става |aaaa | b000 | ch000 | = 12
```

Всяка примитивна член-данна има адрес кратен на големината си!

Размерът на целочислен тип зависи от процесора.
```
//int - 4 bytes x32 & 8 bytes x64
uint32_t a; // 32 bites / 4 bytes
uint64_t b; // 64 bites / 8 bytes
```
Големината на структурата трябжа да се дели на размера на най-голямата примитивна член-данна.

Размерът на указател зависи от процесора.
```
int* ptr; //x64 -> 8 bytes, x32 -> 4 bytes
```

Може да се вкара празен масив САМО накрая на структурата и размера му е равен на падинга останал свободен накрая.
```
struct A {
	char ch;
	int arr[]; //arr - последен елемент
	//в този случай съществуването на променлива от тип инт залага alignment = 4, но понеже няма дефинирани елементи, променливите в структурата изглеждат като |ch000| и sizeof = 4
}

struct A {
	int32_t a;
	char ch;
	char arr[]; //arr с 3 елемента, защото |aaaa|ch000| се запълва с |aaaa|ch arr[0] arr[1] arr[2]|
}

struct A {
	char a;
	int i[];
	int j[]; //НЕ Е ВЪЗМОЖНО!
}
```
Байт - 8 бита. 1 байт има стойност 0-255.

# Union
Обединение - последователност от полета, които споделят една памет.
-	Обединенията е специален вид структура, чиито член-данни(дори и от различен тип) споделят една и съща памет. Едно обединение заема памет, колкото е големината на най-голямата му променлива в обединението. Във всеки един момент обаче може да се ползва само една променлива от състава на обединението.
```
	Union T
	{
		int a;
		char ch;
	};
	//Размерът на Т е 4
	// - - - -
	// a a a a
	// ch

	//При T.a = 65 стойността на T.b = 'a'
```
Обединенията се използват за реализация на полиморфизъм, т.е. ако се нуждае от различна имплементация на подобни структури:
```
	Union Person
	{
		Student s;
		Teacher t;
	};
	//Човек е или ученик или учител
```


  # Endianness
Съществуват следните два начина за запазване на байтовете на типове данни, които имат размер по-голям от 1 байт:

 - Little-endian - Най-старшият байт е на последна позиция, най-младшият е на първа - Това е принципа, на който работят повечето модерни архитектури. Това означава, че ако ние си представяме битовете като a=65 -> 00 00 00 65, те реално се запазват в компютъра като 65 00 00 00.

- Big-endian - Най-старшият байт е на първа позиция, най-младшият е на последна

	Проверката се извършва чрез обединения по следния начин:
```
	void checkEndian()
	{
		Union Check
		{
			int n=1;
			char p;
		}
		if(p==1)cout<<"Little endian"<<endl
		else cout<<"Big endian"<<endl;
	}
```


```
