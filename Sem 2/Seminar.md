# Seminar belejki

Като вземаме с getline не чете новия ред като знак а като delimeter.

ofstream - ако не съществува бива създаден
ifstream - ако не съществува - чупи потока

При подаване на потоци във функции - подаваме по референция, иначе се отваря нов поток, което е бавна операция

Не можем да сложим конст на потоци, защото със записването на всеки символ адресът се променя => const-a се чупи

форматирано четене - пропускаме спейс, таб и нов ред (т.е те служат за разделение между две инстанции)

неформатирани - не пропускат спейс, теб и нов ред (т.е. те са валидни символи, които да бъдат приети)

ако използваме и двете, в потока могат да останат leftover символи

cin.ignore(<брой символи, които да бъдат игнорирани, default 1>); - скипваме символ при четенето от потока.

ако искаме да прочетем файл от папка надолу - "<име на папка>/<име на файл>" (Намираме се в папка А, папка B е в папка А, искаме файл от папка B)

файл от папка нагоре - "../<име на файл>" (Намираме се в папка B, папка B е в папка А, искаме файл от папка A)

TO BE CONTINUED - скрити настройки на ofstream

Ако направим проверка дали някой от файловете, с които работим не е отворен, може някой от тях да се отвори по време на проверка и да остане незатворен. Затова проверките трябва да се правят по отделно и ако някоя след първата даде грешка, да затворим предходните.

tellg() - istream - вземаме къде е индекса на пойнтера спрямо началото

seekg() - istream - на какво разстояние да се премести и спрямо къде

всяко изместване е един байт

ако искаме да вземем размера, трябва да върнем индекса на указателя в началото за да продължим да работим с файла



