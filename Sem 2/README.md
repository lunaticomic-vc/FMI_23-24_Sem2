Поток. Стандартни потоци. Текстови файлове. Йерархия на потоците. Интерфейс на потоци. Потоци за вход/изход от файл. Режими на работа. Флагове на състоянията на потока. Позициониране във файл. Пример за функция, която връща големината на файл. Пример за функция, която връща брой редове в текстов файл.

//Belejka: V kakyl smisyl rejimi na rabota. - update: tva ne e rocket science ama ne sym sig napylno

// V kakyv smisyl pozicionirane. V kakyv smisyl golemina na fail. - update: tva sa seekovete i tellovete no ne sym gi razpisala

# Поток

Дефиниция: Последователност от байтове "насочени" в определена посока, т.е. имат origin & destination (точен цитат от лекция)

При операциите за вход, байтовете идват от източник за вход (клавиатура, файл, мрежа или друга програма)

При операциите за изход, байтовете данни излизат от програмата и се "вливат" във външно "устройство" (конзола, файл, мрежа или друга програма)

Потоците служат като посредници между програмите и самите IO (input/output) устройства по начин, който освобождава програмиста от боравене с тях.

Потокът дефинира интерфейс с операции, които работят по еднакъв начин независимо от типа устройство. 

За да извърши вход или изход, една C++ програма:

- Създава поток;
- Свързва потока с IO устройството (напр. конзола, клавиатура, файл, мрежа или друга програма);
- Извършва операции за вход/изход върху потока;
- Прекъсва връзка с потока;
- Освобождава потока;

cin, cout - видове потоци

# Йерархия
```
//        Iostream
//        /      \
//   istream     ostream
//   /    \      /    \
// ifstream efstream ofstream
```
cin - обект от вид istream

cout - обект от вид ostream

ifstream - поток за вход във файлове

ofstream - поток за изход към файлове

Те са форматирани и неформатирани

- форматирани - при тях няма определен тип символи, които да бъдат вкарани/изкарани. Можеш да cin-неш инт, чар, т.н.
        - cout << nqkvi danni <<endl;
        - cin >> nqkvi danni;  
  
- неформатирани - взимаш и слагаш определени типове
  - get(<1 променлива от тип char>),
  - put(<1 променлива от тип char>),
  - getline(<buffer тип char[]>, <размер>) - взима до запълване на буфер или нов ред, което стане първо

# Работа с файлове

```
ofstream ofs ("file.txt"); //Ако няма такъв се създава.
if(!ofs.is_open()) { //Error handling };
ofs<<37;
ofs.put('x');
```

```
  int x;
  cin>>x; //x='a' -> потокът се счупва
```

Проверка за приключен вход - ifs.eof(); - липсва терминиращ елемент.
Възможно е eof() да даде грешно поведение в цикъл тип
```
while(!ifs.eof())
{
  //защото то отчита края на входа чак след като е прочело елемента 'край на вход'.
// Ако завършва с нов ред, например, а ние търсим броя на новите редове,
// тогава то ще отчете този нов ред, въпреки че той не е практически част от входа.
} 
```
по-добра имплементация е
```
  while(true)
  {
    char p = ifs.get();
    if(ifs.eof())break;
    //...
  }
```
# Режими на работа
## Работа с поток за вход от файл (ifstream)
```
#include <iostream>
#include <fstream>

constexpr char FILE_NAME[] = "myFile.txt";

int main() {
   std::ifstream file(FILE_NAME); // create input file stream associated with myFile.txt

   if (!file.is_open()) {
   	std::cout << "Error!" << std::endl;
   	return -1;
   }
   
   int a, b;
   file >> a >> b;

   file.close();
}
```
```
#include <iostream>
#include <fstream>

constexpr int BUFF_SIZE = 1024;
constexpr char FILE_NAME[] = "myFile.txt";

int main() {
   std::ifstream file(FILE_NAME);

   if (!file.is_open()) {
   	std::cout << "Error!" << std::endl;
   	return -1;
   }
   while(true)
  {
    char p = ifs.get();
    if(ifs.eof())break;
    char buff[BUFF_SIZE];
   	file.getline(buff, BUFF_SIZE);
   	std::cout << buff << std::endl;
  }   
   file.close();
}
```
## Работа с поток за изход към файл (ofstream)

(istream) get - функция, която чете следващия character в потока.

(ostream) put - функция, която поставя на следваща позиция character в потока.

ifstream или istream - съдържа get указател, който реферира елемента, който ще се прочете при следващата входна операция.

ofstream или ostream - съдържа put указател, който реферира мястото, където ще се запише следващият елемент.

put и get не са форматирани за разлика от operator<< и operator>>, тоест не пропускат whitespaces и др.

# Seminar belejki

Като вземаме с getline не чете новия ред като знак а като delimeter.

ofstream - ако не съществува бива създаден
ifstream - ако не съществува - чупи потока

При подаване на потоци във функции - подаваме по референция, иначе се отваря нов поток, което е бавна операция

Не можем да сложим конст на потоци, защото със записването на всеки символ адресът се променя => const-a се чупи

форматирано четене - пропускаме спейс, таб и нов ред (т.е те служат за разделение между две инстанции)

неформатирани - не пропускат спейс, теб и нов ред (т.е. те са валидни символи, които да бъдат приети)

ако използваме и двете, в потока могат да останат leftover символи

cin.ignore(<брой символи, които да бъдат игнорирани, default 1>); - скипваме символ при четенето от потока.

ако искаме да прочетем файл от папка надолу - "<име на папка>/<име на файл>" (Намираме се в папка А, папка B е в папка А, искаме файл от папка B)

файл от папка нагоре - "../<име на файл>" (Намираме се в папка B, папка B е в папка А, искаме файл от папка A)

TO BE CONTINUED - скрити настройки на ofstream

Ако направим проверка дали някой от файловете, с които работим не е отворен, може някой от тях да се отвори по време на проверка и да остане незатворен. Затова проверките трябва да се правят по отделно и ако някоя след първата даде грешка, да затворим предходните.

tellg() - istream - вземаме къде е индекса на пойнтера спрямо началото

seekg() - istream - на какво разстояние да се премести и спрямо къде

всяко изместване е един байт

ако искаме да вземем размера, трябва да върнем индекса на указателя в началото за да продължим да работим с файла



