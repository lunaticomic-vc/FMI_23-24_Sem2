Поток. Стандартни потоци. Текстови файлове. Йерархия на потоците. Интерфейс на потоци. Потоци за вход/изход от файл. Режими на работа. Флагове на състоянията на потока. Позициониране във файл. Пример за функция, която връща големината на файл. Пример за функция, която връща брой редове в текстов файл.

# Поток

Дефиниция: Последователност от байтове "насочени" в определена посока, т.е. имат origin & destination (точен цитат от лекция)

При операциите за вход, байтовете идват от източник за вход (клавиатура, файл, мрежа или друга програма)

При операциите за изход, байтовете данни излизат от програмата и се "вливат" във външно "устройство" (конзола, файл, мрежа или друга програма)

Потоците служат като посредници между програмите и самите IO (input/output) устройства по начин, който освобождава програмиста от боравене с тях.

Потокът дефинира интерфейс с операции, които работят по еднакъв начин независимо от типа устройство. 

За да извърши вход или изход, една C++ програма:

- Създава поток;
- Свързва потока с IO устройството (напр. конзола, клавиатура, файл, мрежа или друга програма);
- Извършва операции за вход/изход върху потока;
- Прекъсва връзка с потока;
- Освобождава потока;

cin, cout - видове потоци

# Йерархия
```
//        Iostream
//        /      \
//   istream     ostream
//   /    \      /    \
// ifstream efstream ofstream
```
cin - обект от вид istream

cout - обект от вид ostream

ifstream - поток за вход във файлове

ofstream - поток за изход към файлове

Те са форматирани и неформатирани

- форматирани - при тях няма определен тип символи, които да бъдат вкарани/изкарани. Можеш да cin-неш инт, чар, т.н.
        - cout << nqkvi danni <<endl;
        - cin >> nqkvi danni;  
  
- неформатирани - взимаш и слагаш определени типове
  - get(<1 променлива от тип char>),
  - put(<1 променлива от тип char>),
  - getline(<buffer тип char[]>, <размер>) - взима до запълване на буфер или нов ред, което стане първо

# Работа с файлове

```
ofstream ofs ("file.txt"); //Ако няма такъв се създава.
if(!ofs.is_open()) { //Error handling };
ofs<<37;
ofs.put('x');
```

```
  int x;
  cin>>x; //x='a' -> потокът се счупва
```

Проверка за приключен вход - ifs.eof(); - липсва терминиращ елемент.
Възможно е eof() да даде грешно поведение в цикъл тип
```
while(!ifs.eof())
{
  //защото то отчита края на входа чак след като е прочело елемента 'край на вход'. Ако завършва с нов ред, например, а ние търсим броя на новите редове, тогава то ще отчете този нов ред, въпреки че той не е практически част от входа.
} 
```
по-добра имплементация е
```
  while(true)
  {
    char p = ifs.get();
    if(ifs.eof())break;
    //...
  }
```
